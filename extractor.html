<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AssetBundle Image Extractor v2.1</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz4js@0.2.0/build/lz4.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            margin: 0 auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 { margin-bottom: 10px; font-size: 24px; }
        .subtitle { color: #666; margin-bottom: 30px; font-size: 14px; }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.01);
        }
        
        .upload-icon { font-size: 48px; margin-bottom: 15px; }
        input[type="file"] { display: none; }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            transition: transform 0.2s, opacity 0.2s;
        }
        
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        
        .progress { margin-top: 20px; display: none; }
        .progress-bar {
            width: 100%; height: 24px; background: #e0e0e0;
            border-radius: 12px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; background: #667eea; width: 0%;
            transition: width 0.3s; display: flex;
            align-items: center; justify-content: center;
            color: white; font-size: 12px; font-weight: bold;
        }
        
        .status {
            margin-top: 20px; padding: 15px; border-radius: 10px;
            display: none; font-size: 14px; text-align: center;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        .debug-info {
            margin-top: 15px; padding: 15px; background: #2d2d2d; color: #0f0;
            border-radius: 10px; font-family: 'Courier New', monospace;
            font-size: 11px; max-height: 150px; overflow-y: auto; display: none;
        }
        
        .file-grid {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 5px;
        }
        
        .file-item {
            position: relative;
            padding-bottom: 100%; /* Square aspect ratio */
            border-radius: 8px;
            overflow: hidden;
            background: #eee;
            border: 1px solid #ddd;
        }
        
        .file-item img {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transition: transform 0.2s;
        }
        
        .file-item:hover img { transform: scale(1.1); }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ AssetBundle Extractor v2.1</h1>
        <p class="subtitle">Support UnityFS, LZ4, et Scanner PNG/JPG</p>
        
       <label class="upload-area" id="uploadArea" for="fileInput">
    <div class="upload-icon">üì¶</div>
    <p><strong>Clique ici ou glisse tes fichiers .bundle / .bin</strong></p>
    <p style="font-size: 12px; color: #666; margin-top: 10px;">Analyse binaire brute</p>
    <input type="file" id="fileInput" multiple>
</label>

        
        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <p id="progressText" style="text-align: center; font-size: 12px; margin-top: 5px; color: #666;">En attente...</p>
        </div>
        
        <div class="status" id="status"></div>
        <div class="file-grid" id="fileGrid"></div>
        <div class="debug-info" id="debugInfo"></div>
        
        <button class="btn" id="downloadBtn" style="display:none;">üì• T√©l√©charger toutes les images (ZIP)</button>
    </div>

    <script>
        // --- √âl√©ments du DOM ---
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const status = document.getElementById('status');
        const debugInfo = document.getElementById('debugInfo');
        const fileGrid = document.getElementById('fileGrid');
        const downloadBtn = document.getElementById('downloadBtn');
        
        // --- Variables Globales ---
        let zip = new JSZip();
        let imageCount = 0;
        let isProcessing = false;

        // --- Event Listeners ---
        uploadArea.addEventListener('click', () => !isProcessing && fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            if(!isProcessing) uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if(!isProcessing) handleFiles(e.dataTransfer.files);
        });
        
        fileInput.addEventListener('change', (e) => {
            if(!isProcessing) handleFiles(e.target.files);
        });

        // --- Logique Principale ---
        async function handleFiles(files) {
            if (files.length === 0) return;
            
            // Reset
            isProcessing = true;
            zip = new JSZip();
            imageCount = 0;
            fileGrid.innerHTML = '';
            debugInfo.innerHTML = '';
            debugInfo.style.display = 'block';
            downloadBtn.style.display = 'none';
            status.style.display = 'none';
            uploadArea.style.opacity = '0.5';
            uploadArea.style.cursor = 'wait';
            
            progress.style.display = 'block';
            
            try {
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    updateProgress((i / files.length) * 100, `Traitement de ${file.name}...`);
                    
                    try {
                        await processAssetBundle(file);
                    } catch (error) {
                        logDebug(`‚ùå Erreur sur ${file.name}: ${error.message}`);
                        console.error(error);
                    }
                }
                
                updateProgress(100, 'Termin√© !');
                
                if (imageCount > 0) {
                    showStatus('success', `‚úÖ ${imageCount} image(s) extraite(s) !`);
                    downloadBtn.textContent = `üì• T√©l√©charger ZIP (${imageCount} images)`;
                    downloadBtn.style.display = 'block';
                } else {
                    showStatus('error', '‚ùå Aucune image lisible trouv√©e (formats support√©s: PNG, JPG).');
                }

            } catch (globalError) {
                showStatus('error', 'Erreur critique: ' + globalError.message);
            } finally {
                isProcessing = false;
                uploadArea.style.opacity = '1';
                uploadArea.style.cursor = 'pointer';
                fileInput.value = ''; // Reset input
            }
        }
        
        async function processAssetBundle(file) {
            const buffer = await file.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            const reader = new BinaryReader(bytes);
            
            // Check Signature
            const signature = reader.readStringNullTerminated();
            reader.position = 0; // Rewind pour l'analyse propre si besoin
            
            logDebug(`üìÑ ${file.name} - Sig: ${signature}`);
            
            let dataToScan = bytes;

            // Logique UnityFS
            if (signature === 'UnityFS') {
                try {
                    dataToScan = await unpackUnityFS(reader, bytes);
                } catch (e) {
                    logDebug(`‚ö†Ô∏è √âchec d√©compression UnityFS: ${e.message}. Scan brut...`);
                    // On continue avec les bytes bruts si la d√©compression √©choue
                }
            } else if (signature === 'UnityWeb') {
                logDebug('‚ö†Ô∏è UnityWeb d√©tect√© (ancien format). Tentative de scan brut.');
            }
            
            // Scan des textures sur les donn√©es (d√©compress√©es ou brutes)
            await extractImagesFromBytes(dataToScan, file.name);
        }

        async function unpackUnityFS(reader, originalBytes) {
            reader.position = 0;
            const signature = reader.readStringNullTerminated(); // UnityFS
            const version = reader.readInt32();
            const unityVersion = reader.readStringNullTerminated();
            const unityRevision = reader.readStringNullTerminated();
            
            const size = reader.readInt64();
            const compressedBlocksInfoSize = reader.readInt32();
            const uncompressedBlocksInfoSize = reader.readInt32();
            const flags = reader.readInt32();
            
            // Type de compression (0: None, 1: LZMA, 2: LZ4, 3: LZ4HC)
            const compressionType = flags & 0x3F;
            const blocksInfoAtEnd = (flags & 0x80) !== 0;
            
            logDebug(`üîß Ver: ${version}, Comp: ${getCompressionName(compressionType)}`);

            let blocksInfoBytes;
            if (blocksInfoAtEnd) {
                reader.position = originalBytes.length - compressedBlocksInfoSize;
                blocksInfoBytes = originalBytes.slice(reader.position, reader.position + compressedBlocksInfoSize);
            } else {
                blocksInfoBytes = originalBytes.slice(reader.position, reader.position + compressedBlocksInfoSize);
            }

            // D√©compression Blocks Info
            let uncompressedBlocksInfo;
            try {
                uncompressedBlocksInfo = decompressBlock(blocksInfoBytes, uncompressedBlocksInfoSize, compressionType);
            } catch (e) {
                throw new Error("Erreur lecture header: " + e.message);
            }

            // Parsing Blocks Info
            const blocksReader = new BinaryReader(uncompressedBlocksInfo);
            blocksReader.position = 16; // Skip GUID
            const blockCount = blocksReader.readInt32();
            
            const blocks = [];
            for (let i = 0; i < blockCount; i++) {
                blocks.push({
                    uncompressedSize: blocksReader.readInt32(),
                    compressedSize: blocksReader.readInt32(),
                    flags: blocksReader.readInt16()
                });
            }

            // Calcul de l'offset des donn√©es
            let dataOffset;
            if (blocksInfoAtEnd) {
                dataOffset = 0; // Apr√®s le header qui est au d√©but
                 // Note: En UnityFS, si info at end, les data suivent le header initial
                 // Le header initial fait une taille variable, on doit le recalculer ou utiliser la position courante du 1er reader
                 // Simplification: On assume que √ßa suit le header initial lu par le premier reader
                 // Hack: header size est approximativement reader.position avant la lecture des blocks
                 // Pour √™tre pr√©cis, on va juste avancer le curseur original
                 const headerSize = signature.length + 1 + 4 + unityVersion.length + 1 + unityRevision.length + 1 + 8 + 4 + 4 + 4;
                 dataOffset = headerSize;
            } else {
                // Header + CompressedBlocksInfo
                const headerSize = signature.length + 1 + 4 + unityVersion.length + 1 + unityRevision.length + 1 + 8 + 4 + 4 + 4;
                dataOffset = headerSize + compressedBlocksInfoSize;
            }

            // D√©compression des Data Blocks
            logDebug(`üì¶ D√©compression de ${blockCount} blocs...`);
            
            // Pr√©-allocation buffer final
            let totalSize = 0;
            blocks.forEach(b => totalSize += b.uncompressedSize);
            let finalData = new Uint8Array(totalSize);
            let currentWritePos = 0;

            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const blockData = originalBytes.slice(dataOffset, dataOffset + block.compressedSize);
                const blockCompression = block.flags & 0x3F;
                
                const decompressedChunk = decompressBlock(blockData, block.uncompressedSize, blockCompression);
                finalData.set(decompressedChunk, currentWritePos);
                
                currentWritePos += block.uncompressedSize;
                dataOffset += block.compressedSize;
            }

            logDebug(`‚úÖ Donn√©es d√©compress√©es: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
            return finalData;
        }

        function decompressBlock(data, targetSize, type) {
            if (type === 1) { // LZMA
                // LZMA est complexe en pur JS sans worker lourd. On tente Pako mais √ßa √©choue souvent sur Unity LZMA
                // Retourne raw si √©chec, le scanner fera de son mieux
                try { return pako.inflate(data); } catch(e) { return data; }
            } 
            else if (type === 2 || type === 3) { // LZ4 / LZ4HC
                try {
                    // Allouer buffer de sortie exact
                    const output = new Uint8Array(targetSize);
                    // lz4js attend un Buffer-like, Uint8Array fonctionne
                    const decodedSize = lz4js.decompress(data, output);
                    return output;
                } catch (e) {
                    console.error("LZ4 Error", e);
                    throw new Error("LZ4 d√©compression √©chou√©e");
                }
            }
            return data; // Pas de compression
        }

        async function extractImagesFromBytes(data, fileName) {
            logDebug('üîç Scan des signatures PNG/JPG...');
            
            const len = data.length;
            
            for (let i = 0; i < len - 4; i++) {
                
                // --- D√©tection PNG (89 50 4E 47) ---
                if (data[i] === 0x89 && data[i+1] === 0x50 && data[i+2] === 0x4E && data[i+3] === 0x47) {
                    // Trouver IEND (49 45 4E 44) + CRC (4 bytes)
                    let end = i + 8;
                    // Optimisation: Sauter header minimal
                    while (end < len - 8) {
                        if (data[end] === 0x49 && data[end+1] === 0x45 && data[end+2] === 0x4E && data[end+3] === 0x44) {
                            end += 8; // IEND + 4 bytes CRC
                            
                            const imgData = data.slice(i, end);
                            // V√©rification basique taille min
                            if (imgData.length > 60) {
                                await addImageToZip(imgData, 'png', fileName);
                                i = end - 1; 
                            }
                            break;
                        }
                        end++;
                        // S√©curit√© boucle infinie / trop long
                        if (end - i > 20_000_000) break; // Max 20MB par image
                    }
                }
                
                // --- D√©tection JPEG (FF D8 FF ...) ---
                // JPEG commence par FF D8 et termine par FF D9
                else if (data[i] === 0xFF && data[i+1] === 0xD8 && data[i+2] === 0xFF) {
                    let end = i + 2;
                    while (end < len - 1) {
                        // Marqueur de fin EOI (FF D9)
                        if (data[end] === 0xFF && data[end+1] === 0xD9) {
                            end += 2;
                            const imgData = data.slice(i, end);
                            if (imgData.length > 100) {
                                await addImageToZip(imgData, 'jpg', fileName);
                                i = end - 1;
                            }
                            break;
                        }
                        end++;
                         if (end - i > 20_000_000) break;
                    }
                }
            }
        }

        async function addImageToZip(data, ext, sourceFile) {
            const imgName = `${sourceFile}_img_${imageCount}.${ext}`;
            const blob = new Blob([data], {type: `image/${ext}`});
            
            zip.file(imgName, blob);
            imageCount++;
            
            // Preview (limit√©e pour perf)
            if (imageCount <= 50) {
                const url = URL.createObjectURL(blob);
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `<img src="${url}" title="${imgName}">`;
                fileGrid.appendChild(div);
            }
        }

        // --- T√©l√©chargement ZIP (Code manquant corrig√©) ---
        downloadBtn.addEventListener('click', async () => {
            if (imageCount === 0) return;
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = "‚è≥ Compression en cours...";
            
            try {
                const content = await zip.generateAsync({type: "blob"});
                const url = window.URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = "assets_extraits.zip";
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                downloadBtn.textContent = "‚úÖ T√©l√©chargement lanc√©";
                setTimeout(() => {
                    downloadBtn.disabled = false;
                    downloadBtn.textContent = `üì• T√©l√©charger ZIP (${imageCount} images)`;
                }, 3000);
            } catch (e) {
                showStatus('error', "Erreur ZIP: " + e.message);
                downloadBtn.disabled = false;
            }
        });

        // --- Utilitaires ---
        function getCompres
